<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Yuuki Theory - Solar System & Planet Nine</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        #ui { position: absolute; top: 20px; left: 20px; color: #7df9ff; pointer-events: none; text-shadow: 0 0 8px #00ffff; }
        .planet-label { font-size: 0.9rem; color: #facc15; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>YUUKI COLLAPSE: SOLAR SYSTEM</h1>
        <div id="target-info">Focus: Sun (m0 Calibration)</div>
        <div style="margin-top:10px; font-size:0.8rem; color:rgba(125,249,255,0.7)">
            *Distances and speeds are scaled for Theory visualization.
        </div>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.150.1/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- Data ---
        // Yuuki Theoryの質量定規的な比率を意識した配置
        const planets = [
            { name: "Mercury", dist: 10, size: 0.4, speed: 0.04, color: 0xaaaaaa },
            { name: "Venus", dist: 15, size: 0.9, speed: 0.015, color: 0xffcc00 },
            { name: "Earth", dist: 20, size: 1.0, speed: 0.01, color: 0x2244ff },
            { name: "Mars", dist: 25, size: 0.5, speed: 0.008, color: 0xff4422 },
            { name: "Jupiter", dist: 40, size: 3.0, speed: 0.004, color: 0xffaa88 },
            { name: "Saturn", dist: 55, size: 2.5, speed: 0.002, color: 0xead6b8 },
            { name: "Uranus", dist: 70, size: 1.5, speed: 0.001, color: 0x88ccff },
            { name: "Neptune", dist: 85, size: 1.5, speed: 0.0008, color: 0x4466ff },
            // プラネットナイン: 遠方で特異な軌道を持つ「理論上の収束点」
            { name: "Planet Nine", dist: 150, size: 1.8, speed: 0.0003, color: 0x6600ff, isP9: true }
        ];

        // --- Objects ---
        // 太陽 (世界の中心 - m0)
        const sunGeo = new THREE.SphereGeometry(4, 32, 32);
        const sunMat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
        const sun = new THREE.Mesh(sunGeo, sunMat);
        scene.add(sun);

        // 太陽の光
        const sunLight = new THREE.PointLight(0xffffff, 2, 500);
        scene.add(sunLight);

        const planetMeshes = [];
        planets.forEach(p => {
            // 軌道
            const orbitGeo = new THREE.RingGeometry(p.dist - 0.1, p.dist + 0.1, 128);
            const orbitMat = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
            const orbit = new THREE.Mesh(orbitGeo, orbitMat);
            orbit.rotation.x = Math.PI / 2;
            if (p.isP9) orbit.rotation.x = Math.PI / 2.5; // プラネットナインは傾いている
            scene.add(orbit);

            // 惑星本体
            const geo = new THREE.SphereGeometry(p.size, 32, 32);
            const mat = new THREE.MeshStandardMaterial({ color: p.color });
            const mesh = new THREE.Mesh(geo, mat);
            
            planetMeshes.push({ mesh, data: p, angle: Math.random() * Math.PI * 2 });
            scene.add(mesh);
        });

        // 背景の星
        const starGeo = new THREE.BufferGeometry();
        const starCount = 10000;
        const posArray = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) posArray[i] = (Math.random() - 0.5) * 2000;
        starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const starMat = new THREE.PointsMaterial({ size: 0.7, color: 0xffffff });
        scene.add(new THREE.Points(starGeo, starMat));

        camera.position.set(0, 100, 150);
        camera.lookAt(0, 0, 0);

        // --- Animation ---
        function animate() {
            requestAnimationFrame(animate);

            planetMeshes.forEach(p => {
                p.angle += p.data.speed;
                const x = Math.cos(p.angle) * p.data.dist;
                const z = Math.sin(p.angle) * p.data.dist;
                
                if (p.data.isP9) {
                    // 傾いた軌道の計算
                    p.mesh.position.set(x, z * 0.3, z); 
                } else {
                    p.mesh.position.set(x, 0, z);
                }
                p.mesh.rotation.y += 0.02;
            });

            sun.rotation.y += 0.005;
            renderer.render(scene, camera);
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
